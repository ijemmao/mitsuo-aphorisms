<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8>
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
      background-color: #ffffff;
      font-family: 'Avenir';
      user-select: none;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%
    }

    h1 {
      padding-left: 30px;
    }

    .aphorisms-container {
      position: absolute;
      overflow-y: scroll;
      height: 100%;
      color: white;
    }

    .aphorism-container {
      border: 1px solid white;
      background-color: black;
      border-radius: 5px;
      cursor: pointer;
      margin: 40px;
      padding: 0 30px;
      width: 17vw;
      min-width: 400px;
    }

    h2 {
      position: relative;
      top: -20px;
      background-color: black;
      width: fit-content;
      padding: 0 5px;
      border: 1px solid white;
      border-radius: 5px;
      margin: 0;
    }

    h3 {
      margin-bottom: 0;
      color: rgb(156, 216, 249);
    }

    h4 {
      margin-top: 5px;
    }

    h3:hover {
      color: #260516;
      color: rgb(101, 201, 255);
    }
  </style>
</head>

<body>
  <div class="aphorisms-container">
    <h1>Aphorisms</h1>
    <div class="aphorism-container" id="1">
      <h2>Virtue</h2>
      <h3>この世は私が私になるところあなたがあなたになるところ</h3>
      <h4>This world has made me and you who we are today</h4>
      <h3>なんにも欲しがらぬとさが一番強い</h3>
      <h4>The desire for nothing is the strongest</h4>
      <h3>ほんとうのことがいちばんいい</h3>
      <h4>Honesty is the best policy</h4>
    </div>
    <div class="aphorism-container" id="2">
      <h2>Carpe Diem</h2>
      <h3>いまが大事</h3>
      <h4>Live in the now</h4>
      <h3>いのちいっぱい</h3>
      <h4>Life is vast</h4>
      <h3>経験してはじめて身につくんだなあ</h3>
      <h4>You truly learn from experience</h4>
      <h3>どうでもいいものはどうでもいいんだよいちばん大事なことに一番大事ないのちをかけてゆくことだ</h3>
      <h4>It doesn't matter what you do, the most important thing is to live the best life you can</h4>
      <h3>その時自分ならばどうする</h3>
      <h4>What would I have done then?</h4>
    </div>
    <div class="aphorism-container" id="3">
      <h2>Humans</h2>
      <h3>人間人間人間第一</h3>
      <h4>Humanity is formidable</h4>
      <h3>ひとのことじゃないんだよじぶんのことだよ</h3>
      <h4>It's not people's issue, it's your issue</h4>
    </div>
    <div class="aphorism-container" id="4">
      <h2>Happiness</h2>
      <h3>しあれせはいつもじぶんのこころがきめる</h3>
      <h4>Happiness is always determined by your heart</h4>
      <h3>一番わかっているようで一番わからぬこの自分</h3>
      <h4>Even though it seems like I know the most, I know the least about myself</h4>
      <h3>あのときのあの苦しみもあのときのあの悲しみもみんな肥料になったんだなあじぶんが自分なるための</h3>
      <h4>The pain and sadness at that time was the fertilizer that I needed to become who I am today</h4>
    </div>
    <div class="aphorism-container" id="5">
      <h2>Loving Others</h2>
      <h3>あなたのこころがきれいだからなんでもきれいに見えるんだなあ</h3>
      <h4>You're so beautiful because your heart is kind</h4>
      <h3>あなたの声を電話で聞いただけでその日一日心がなごむ理屈じゃねんだよなあ</h3>
      <h4>Hearing your voice the other day is the reason why I'm so relaxed</h4>
    </div>
  </div>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script>
    let aphorism = '1';
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set(0, 0, 100);
    camera.lookAt(0, 0, 0);
    let controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enabled = true;
    controls.enableKeys = true;
    controls.keys = {
      LEFT: 65, //left arrow
      UP: 87, // up arrow
      RIGHT: 68, // right arrow
      BOTTOM: 83 // down arrow
    }
    controls.minDistance = 0;
    controls.maxDistance = 150;
    controls.update();
    let mouseX = 0;
    let mouseY = 0;
    let windowHalfX = window.innerWidth / 2;
    let windowHalfY = window.innerHeight / 2;
    let scene = new THREE.Scene();
    let time = 0;
    let lifeCubes = new THREE.Group();
    let waves = new THREE.Group();
    let conesGroup = new THREE.Group();
    const ROTATION_SPEED = .01;
    let pinkPlanetGroup;
    let greenPlanetGroup;
    let innerCube;

    function CustomSinCurve(scale, type) {

      THREE.Curve.call(this);

      this.scale = (scale === undefined) ? 1 : scale;
      this.type = type;
    }

    CustomSinCurve.prototype = Object.create(THREE.Curve.prototype);
    CustomSinCurve.prototype.constructor = CustomSinCurve;

    CustomSinCurve.prototype.getPoint = function (t) {
      let tx = 1 * t * 3 - 1.5;
      let ty = 0;
      if (this.type === 'first') {
        ty = Math.cos(Math.sin(time / 5) * Math.PI * t) * Math.sin(Math.cos(time / 5) * Math.PI * t);
      } else if (this.type === 'second') {
        ty = Math.cos(Math.cos(time / 5) * Math.PI * t) * Math.sin(Math.sin(time / 5) * Math.PI * t);
      }
      let tz = 1;

      return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);

    };

    const random = (min, max) => {
      return Math.random() * (+max - +min) + +min;
    }

    const lifeCubeGroup = new THREE.Group();
      for (let i = 0; i < 7; i++) {
        let geometry = new THREE.BoxBufferGeometry(1, 1, 1);
        let material = new THREE.MeshNormalMaterial();
        let cube = new THREE.Mesh(geometry, material);
        cube.position.set(i * 2, i * i / 4, 0);
        lifeCubeGroup.add(cube);
        
      }

    const generateLifeCubes = (count) => {
      for (let i = 0; i < count; i++) {
        let cloneLifeCubeGroup = lifeCubeGroup.clone(true);
        cloneLifeCubeGroup.position.set(random(-200, 200), random(-200, 200), random(-200, 200))
        scene.add(cloneLifeCubeGroup)
      }
    }

    const generateStars = (count) => {
      for (let i = 0; i < count; i++) {
        let geometry = new THREE.BoxBufferGeometry(.1, .1, .1);
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        let cube = new THREE.Mesh(geometry, material);
        cube.position.set(random(-100, 100), random(-100, 100), random(-100, 100));
        scene.add(cube);
      }
    }

    const rotateInnerCube = () => {
      innerCube.rotation.x -= ROTATION_SPEED * 3;
      innerCube.rotation.y -= ROTATION_SPEED;
      innerCube.rotation.z -= ROTATION_SPEED;
    }

    const generatePlanetary = () => {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      pinkPlanetGroup = new THREE.Group();
      greenPlanetGroup = new THREE.Group();
      let sphere = new THREE.Mesh(new THREE.SphereGeometry(5, 20, 20), new THREE.MeshBasicMaterial({ color: 0xf00fff, transparent: true, opacity: 0.5 }));
      pinkPlanetGroup.add(sphere);
      sphere = new THREE.Mesh(new THREE.SphereGeometry(2, 20, 20), new THREE.MeshNormalMaterial({ side: THREE.BackSide }));
      pinkPlanetGroup.add(sphere);
      sphere = new THREE.Mesh(new THREE.SphereGeometry(7, 20, 20), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
      greenPlanetGroup.add(sphere);
      sphere = new THREE.Mesh(new THREE.SphereGeometry(3, 20, 20), new THREE.MeshNormalMaterial({ side: THREE.BackSide }));
      greenPlanetGroup.add(sphere);
      scene.add(pinkPlanetGroup)
      scene.add(greenPlanetGroup)
      generateStars(1500);
    }

    const generateConesGroup = (count) => {
      for (let j = 0; j < count; j++) {
        const subConeGroup = new THREE.Group();
        for (let i = 0; i < 6; i++) {
          let coneGeometry = new THREE.ConeBufferGeometry(1, 2, 64)
          let material = new THREE.MeshNormalMaterial();
          let cone = new THREE.Mesh(coneGeometry, material);
          cone.rotation.z = i;
          cone.position.x = Math.cos(Math.PI * 360 / i) * -3;
          cone.position.y = Math.sin(Math.PI * 360 / i) * -3;
          subConeGroup.add(cone);
        }
        subConeGroup.position.set(Math.round(random(-100, 100)), Math.round(random(-100, 100)), 0)
        conesGroup.add(subConeGroup)
      }
    }

    // Generate Planetary
    generatePlanetary();



    let renderAphorism = (aphorism) => {
      if (aphorism === '1') {
        pinkPlanetGroup.position.set(Math.cos(time) * 10, Math.sin(time) * 10, 0);
        greenPlanetGroup.position.set(Math.sin(time) * 20, Math.cos(time) * 20, Math.sin(time) * 20);

      } else if (aphorism === '2') {
      } else if (aphorism === '3') {
        lifeCubes.position.set(lifeCubes.position.x - .05, lifeCubes.position.y - .05, lifeCubes.position.z)
        console.log(innerCube);
        rotateInnerCube();
      } else if (aphorism === '4') {
        waves.children.forEach((wave, index) => {
          if (index === 4) {
            wave.geometry = new THREE.TubeBufferGeometry(new CustomSinCurve(10, 'second'), 100, .7, 40, false);
          } else {
            wave.geometry = new THREE.TubeBufferGeometry(new CustomSinCurve(10, 'first'), 100, .7, 40, false);
          }
        })
      } else if (aphorism === '5') {
        document.removeEventListener('mousemove', onDocumentMouseMove, true);
        conesGroup.children.forEach((coneGroup) => {
          coneGroup.position.z = Math.cos(Math.sin(time / 5) * Math.PI * random(0, 1))
        })
      }
    }

    let animate = () => {
      time += .07;

      camera.position.x += (mouseX - camera.position.x) * .05;
      camera.position.y += (- mouseY - camera.position.y) * .05;

      requestAnimationFrame(animate);
      renderAphorism(aphorism);
      renderer.render(scene, camera);
    }
    animate();

    onDocumentMouseMove = (event) => {
      mouseX = (event.clientX - windowHalfX) / 25;
      mouseY = (event.clientY - windowHalfY) / 25;
    }

    onWindowResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousemove', onDocumentMouseMove, true);
    document.addEventListener('mousedown', () => {
      document.removeEventListener('mousemove', onDocumentMouseMove, true);
    }, false);
    document.addEventListener('mouseup', () => {
      document.addEventListener('mousemove', onDocumentMouseMove, true);
    }, false);

    Array.from(document.getElementsByClassName('aphorism-container')).forEach((element) => {
      element.addEventListener('click', (e) => {
        let selectedContainer = e.target;
        if (e.target.tagName === 'H3') selectedContainer = e.target.parentNode
        aphorism = selectedContainer.id;
        scene = new THREE.Scene();
        document.addEventListener('mousemove', onDocumentMouseMove, true);
        // camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
        camera.position.set(0, 0, 100);
        camera.lookAt(0, 0, 0);
        switch (aphorism) {
          case '1':
            generatePlanetary();
            break;
          case '2':
            scene.background = new THREE.Color(0xffb085);
            generateLifeCubes(4000);
            break;
          case '3':
            scene.background = new THREE.Color(0x3c5929);
            for (let i = 0; i < 300; i++) {
              let geometry;

              switch (Math.round(random(0, 3))) {
                case 0:
                  geometry = new THREE.BoxBufferGeometry(2, Math.round(random(1, 5)), 2);
                  break;
                case 1:
                  geometry = new THREE.DodecahedronBufferGeometry(Math.round(random(1, 3)), 0);
                  break;
                case 2:
                  geometry = new THREE.CylinderGeometry(1, Math.round(random(0, 2)), 2, 32);
                  break;
                case 3:
                  geometry = new THREE.TorusKnotBufferGeometry(1, .2, 100, 16);;
                  break;
                default:
                  break;
              }
              let material = new THREE.MeshNormalMaterial();
              let cube = new THREE.Mesh(geometry, material);
              cube.position.set(random(.5, 10) * Math.cos(360 / i) * 9, random(.5, 10) * Math.round(random(-10, 10)), random(.5, 10) * Math.sin(360 / i) * 9);
              scene.add(cube)
            }
            let geometry = new THREE.BoxBufferGeometry(2, 2, 2);
            let yellowMaterial = new THREE.MeshBasicMaterial({ color: 0xfff000, transparent: true, opacity: 0.5 });
            let cube = new THREE.Mesh(geometry, yellowMaterial);
            scene.add(cube)
            let innerCubeGeometry = new THREE.BoxBufferGeometry(.5, .5, .5);
            let innerCubeMaterial = new THREE.MeshNormalMaterial();
            innerCube = new THREE.Mesh(innerCubeGeometry, innerCubeMaterial);
            scene.add(innerCube)
            break;
          case '4':
            waves = new THREE.Group();
            let waveMaterial = new THREE.MeshNormalMaterial();
            for (let i = -1; i < 2; i++) {
              for (let j = -1; j < 2; j++) {
                let wave;
                if (i === j && i === 0 && j === 0) {
                  wave = new THREE.Mesh(new THREE.TubeBufferGeometry(new CustomSinCurve(10, 'second'), 100, .7, 40, false), waveMaterial);
                } else {
                  wave = new THREE.Mesh(new THREE.TubeBufferGeometry(new CustomSinCurve(10, 'first'), 100, .7, 40, false), waveMaterial);
                }
                wave.position.set(wave.position.x - i * 30, wave.position.y - j * 30, wave.position.z);
                waves.add(wave);
              }
            }
            scene.add(waves);
            break;
          case '5':
            scene.background = new THREE.Color(0x260516);
            conesGroup = new THREE.Group(3, 64, 64);
            document.removeEventListener('mousemove', onDocumentMouseMove, true);
            generateConesGroup(600);
            let calmGeometry = new THREE.SphereGeometry();
            let calmMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
            let calmSphere = new THREE.Mesh(calmGeometry, calmMaterial);
            scene.add(conesGroup)
            scene.add(calmSphere);
            break;
          default:
            break;
        }
      })
    })
  </script>
</body>

</html>