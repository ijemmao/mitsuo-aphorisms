<!DOCTYPE html>
<html>

<head>
  <meta charset=utf-8>
  <title>My first three.js app</title>
  <style>
    body {
      margin: 0;
      background-color: #ffffff;
      font-family: 'Avenir';
      user-select: none;
    }

    canvas {
      width: 100%;
      height: 100%
    }

    h1 {
      padding-left: 30px;
    }

    .aphorisms-container {
      position: absolute;
      color: white;
    }

    .aphorism-container {
      border: 1px solid white;
      border-radius: 5px;
      cursor: pointer;
      margin: 20px;
      padding: 0 30px;
      width: 600px;
    }

    h3:hover {
      color: #ed7737;
      color: rgb(101, 201, 255);
    }
  </style>
</head>

<body>
  <div class="aphorisms-container">
    <h1>Aphorisms</h1>
    <div class="aphorism-container" id="1">
      <h3>この世は私が私になるところあなたがあなたになるところ</h3>
      <h3>なんにも欲しがらぬとさが一番強い</h3>
      <h3>ほんとうのことがいちばんいい</h3>
    </div>
    <div class="aphorism-container" id="2">
      <h3>しあれせはいつもじぶんのこころがきめる</h3>
      <h3>そのままでいいがな</h3>
      <h3>あのときのあの苦しみもあのときのあの悲しみもみんな肥料になったんだなあじぶんが自分なるための</h3>
    </div>
    <div class="aphorism-container" id="3">
      <h3>いまが大事</h3>
      <h3>いのちいっぱい</h3>
      <h3>経験してはじめて身につくんだなあ</h3>
      <h3>どうでもいいものはどうでもいいんだよいちばん大事なことに一番大事ないのちをかけてゆくことだ</h3>
      <h3>その時自分ならばどうする</h3>
    </div>
    <div class="aphorism-container" id="4">
      <h3>人間人間人間第一</h3>
      <h3>ひとのことじゃないんだよじぶんのことだよ</h3>
    </div>
    <div class="aphorism-container" id="5">
      <h3>あなたのこころがきれいだからなんでもきれいに見えるんだなあ</h3>
      <h3>あなたの声を電話で聞いただけでその日一日心がなごむ理屈じゃねんだよなあ</h3>
    </div>
  </div>
  <script src="js/three.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script>
    let currentAphorism = '1';
    let renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set(0, 0, 100);
    camera.lookAt(0, 0, 0);
    let controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.update();
    let scene = new THREE.Scene();
    let time = 0;
    const lifeCubes = new THREE.Group();
    const waves = new THREE.Group();

    function CustomSinCurve(scale, type) {

        THREE.Curve.call(this);

        this.scale = (scale === undefined) ? 1 : scale;
        this.type = type;
      }

      CustomSinCurve.prototype = Object.create(THREE.Curve.prototype);
      CustomSinCurve.prototype.constructor = CustomSinCurve;

      CustomSinCurve.prototype.getPoint = function (t) {
        let tx = 1 * t * 3 - 1.5;
        let ty = 0;
        if (this.type === 'first') {
          ty = Math.cos(Math.sin(time / 5) * Math.PI * t) * Math.sin(Math.cos(time / 5) * Math.PI * t);
        } else if (this.type === 'second') {
          ty = Math.cos(Math.cos(time) * Math.PI * t) * Math.sin(Math.sin(time) * Math.PI * t);
        }
        let tz = 1;

        return new THREE.Vector3(tx, ty, tz).multiplyScalar(this.scale);

      };

    let random = (min, max) => {
      return Math.random() * (+max - +min) + +min; 
    }

    let generateLifeCubes = (count) => {
      for (let j = 0; j < count; j++) {
        const lifeCubes = new THREE.Group();
          for (let i = 0; i < 7; i++) {
            let geometry = new THREE.BoxGeometry(1, 1, 1);
            let material = new THREE.MeshNormalMaterial();
            let cube = new THREE.Mesh(geometry, material);
            cube.position.set(i * 2, i * i / 4, 0);
            lifeCubes.add(cube);
            lifeCubes.position.set(random(-90, 90), random(-90, 90), random(-90, 90))
          }
          scene.add(lifeCubes)
        }
    }

    let generateStars = (count) => {
      for (let i = 0; i < count; i++) {
        let geometry = new THREE.BoxGeometry(.1, .1, .1);
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff });
        let cube = new THREE.Mesh(geometry, material);
        cube.position.set(random(-100, 100), random(-100, 100), random(-100, 100));
        scene.add(cube);
      }
    }

    // Generate Planetary
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    const pinkPlanetGroup = new THREE.Group();
    const greenPlanetGroup = new THREE.Group();
    let sphere = new THREE.Mesh(new THREE.SphereGeometry(5, 20, 20), new THREE.MeshBasicMaterial({ color: 0xf00fff, transparent: true, opacity: 0.5 }));
    pinkPlanetGroup.add(sphere);
    sphere = new THREE.Mesh(new THREE.SphereGeometry(2, 20, 20), new THREE.MeshNormalMaterial({ side: THREE.BackSide }));
    pinkPlanetGroup.add(sphere);
    sphere = new THREE.Mesh(new THREE.SphereGeometry(7, 20, 20), new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 }));
    greenPlanetGroup.add(sphere);
    sphere = new THREE.Mesh(new THREE.SphereGeometry(3, 20, 20), new THREE.MeshNormalMaterial({ side: THREE.BackSide }));
    greenPlanetGroup.add(sphere);
    scene.add(pinkPlanetGroup)
    scene.add(greenPlanetGroup)
    generateStars(1500);

    
   
    let renderAphorism = (aphorism) => {
      
      if (aphorism === '1') {
        pinkPlanetGroup.position.set(Math.cos(time) * 10, Math.sin(time) * 10, 0);
        greenPlanetGroup.position.set(Math.sin(time) * 20, Math.cos(time) * 20, Math.sin(time) * 20);
        
      } else if (aphorism === '2') {
      } else if (aphorism === '3') {
        scene.background = new THREE.Color(0xed7737)
        lifeCubes.position.set(lifeCubes.position.x - .05, lifeCubes.position.y - .05, lifeCubes.position.z)
      } else if (aphorism === '4') {
        waves.children.forEach((wave) => {
          wave.geometry = new THREE.TubeBufferGeometry(new CustomSinCurve(10, 'first'), 100, .7, 40, false);
        })
      }
    }
    
    let animate = () => {
      time += .07;
      requestAnimationFrame(animate);
      renderAphorism(currentAphorism);
      renderer.render(scene, camera);
    }
    animate();

    
    Array.from(document.getElementsByClassName('aphorism-container')).forEach((element) => {
      element.addEventListener('click', (e) => {
          let selectedContainer = e.target;
          if (e.target.tagName === 'H3') selectedContainer = e.target.parentNode
          let currentAphorism = selectedContainer.id;
          scene = new THREE.Scene();
          switch (currentAphorism) {
            case '1':
              scene.background = new THREE.Color(0x000000);
              const pinkPlanetGroup = new THREE.Group();
              const greenPlanetGroup = new THREE.Group();
              let sphere = new THREE.Mesh(new THREE.SphereGeometry(5, 20, 20), new THREE.MeshBasicMaterial({ color: 0xf00fff, transparent: true, opacity: 0.5 }));
              pinkPlanetGroup.add(sphere);
              sphere = new THREE.Mesh(new THREE.SphereGeometry(2, 20, 20), new THREE.MeshNormalMaterial({ side: THREE.BackSide }));
              pinkPlanetGroup.add(sphere);
              sphere = new THREE.Mesh(new THREE.SphereGeometry(7, 20, 20), new THREE.MeshBasicMaterial({ color: 0xf00aff, transparent: true, opacity: 0.5 }));
              greenPlanetGroup.add(sphere);
              sphere = new THREE.Mesh(new THREE.SphereGeometry(3, 20, 20), new THREE.MeshNormalMaterial({ side: THREE.BackSide }));
              greenPlanetGroup.add(sphere);
              scene.add(pinkPlanetGroup)
              scene.add(greenPlanetGroup)
              generateStars(1500);
            break;
            case '2':
              const lifeCubes = new THREE.Group();
              generateLifeCubes(600);
              for (let i = 0; i < 7; i++) {
                let geometry = new THREE.BoxGeometry(1, 1, 1);
                let material = new THREE.MeshNormalMaterial();
                let cube = new THREE.Mesh(geometry, material);
                cube.position.set(i * 2, i * i / 4, 0);
                lifeCubes.add(cube);
              }
              scene.add(lifeCubes);
            break;
            case '3':
              for (let i = 0; i < 20; i++) {
                let geometry = new THREE.BoxGeometry(2, 2, 2);
                let material = new THREE.MeshNormalMaterial();
                let cube = new THREE.Mesh(geometry, material);
                cube.position.set(Math.cos(360 / i) * 9, 0, Math.sin(360 / i) * 9);
                scene.add(cube)
              }
              let geometry = new THREE.BoxGeometry(2, 2, 2);
              let material = new THREE.MeshBasicMaterial({ color: 0xfff000, transparent: true, opacity: 0.5 });
              let cube = new THREE.Mesh(geometry, material);
              scene.add(cube)
              geometry = new THREE.BoxGeometry(.5, .5, .5);
              material = new THREE.MeshNormalMaterial();
              cube = new THREE.Mesh(geometry, material);
              scene.add(cube)
              geometry = new THREE.BoxGeometry(200, .1, 200);
              material = new THREE.MeshDepthMaterial({ color: 0xaaaaaa });
              cube = new THREE.Mesh(geometry, material);
              cube.position.set(cube.position.x, cube.position.y - 1, cube.position.z);
              scene.add(cube)
            break;
            case '4':
              let material = new THREE.MeshNormalMaterial();
              for (let i = -1; i < 2; i++) {
                for (let j = -1; j < 2; j++) {
                  let wave = new THREE.Mesh(new THREE.TubeBufferGeometry(new CustomSinCurve(10, 'first'), 100, .7, 40, false), material);
                  wave.position.set(wave.position.x - i * 30, wave.position.y - j * 30, wave.position.z);
                  waves.add(wave);
                }
              }
              scene.add(waves);
            break;
            default:
            break;
          }
        })
      })
  </script>
</body>

</html>